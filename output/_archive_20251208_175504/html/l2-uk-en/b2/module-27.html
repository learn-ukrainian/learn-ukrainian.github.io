<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Module 27: History: Kyivan Rus I | Ukrainian B2</title>
  <style>
:root { --primary: #1a5fb4; --primary-light: #3584e4; --success: #26a269; --warning: #e5a50a; --danger: #c01c28; --bg: #fafafa; --card-bg: #fff; --text: #1e1e1e; --text-muted: #5e5e5e; --border: #e0e0e0; }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; }
.top-nav { background: #2e2e2e; color: white; padding: 0.5rem 2rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.875rem; }
.top-nav a { color: white; text-decoration: none; }
.top-nav a:hover { text-decoration: underline; }
.module-nav { display: flex; gap: 1rem; align-items: center; }
.module-nav-link { color: rgba(255,255,255,0.8); text-decoration: none; padding: 0.25rem 0.5rem; }
.module-nav-link:hover { color: white; }
.module-nav-link.disabled { color: rgba(255,255,255,0.3); pointer-events: none; }
.nav { position: sticky; top: 0; background: var(--primary); color: white; padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; z-index: 100; }
.nav h1 { font-size: 1.25rem; }
.nav-tabs { display: flex; gap: 0.5rem; }
.nav-tab { background: rgba(255,255,255,0.2); border: none; color: white; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; }
.nav-tab.active { background: white; color: var(--primary); }
main { max-width: 1000px; margin: 0 auto; padding: 2rem; }
.section { display: none; } .section.active { display: block; }
.lesson-header { text-align: center; margin-bottom: 2rem; padding: 2rem; background: linear-gradient(135deg, #e8f4fd, #f0e8fd); border-radius: 12px; }
.level-badge { background: var(--primary); color: white; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.875rem; }
.card { background: var(--card-bg); border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 1.5rem; margin-bottom: 1.5rem; }
.card h3 { color: var(--primary); margin-bottom: 1rem; }
.section-intro { border-left: 4px solid var(--primary); }
.section-intro h3 { color: var(--primary); }
.section-topic { border-left: 4px solid var(--border); }
.section-summary { background: linear-gradient(135deg, #f0f9ff, #e8f4fd); border-left: 4px solid var(--success); }
.section-summary h3 { color: var(--success); }
.canvas-note { background: #fffbeb; border-left: 4px solid var(--warning); padding: 1rem; margin: 1rem 0; border-radius: 0 8px 8px 0; }
.canvas-note h4 { color: var(--warning); margin-bottom: 0.5rem; }
.md-content { line-height: 1.7; }
.md-content p { margin: 0.75rem 0; }
.md-content ul, .md-content ol { margin: 0.75rem 0; padding-left: 1.5rem; }
.md-content li { margin: 0.25rem 0; }
.md-content strong { color: var(--primary); }
.md-content blockquote { background: #e8f4fd; border-left: 4px solid var(--primary); padding: 0.75rem 1rem; margin: 1rem 0; border-radius: 0 8px 8px 0; }
.md-content blockquote p { margin: 0.25rem 0; }
.md-content table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
.md-content th, .md-content td { border: 1px solid var(--border); padding: 0.5rem 0.75rem; text-align: left; }
.md-content th { background: #f5f5f5; font-weight: 600; }
.md-content code { background: #f0f0f0; padding: 0.125rem 0.375rem; border-radius: 4px; font-family: monospace; font-size: 0.9em; }
.md-content details { background: #f8f9fa; border: 1px solid var(--border); border-radius: 8px; padding: 0; margin: 1rem 0; }
.md-content details summary { background: linear-gradient(135deg, #e8f4fd, #f0e8fd); padding: 0.75rem 1rem; cursor: pointer; font-weight: 600; color: var(--primary); border-radius: 8px; list-style: none; display: flex; align-items: center; gap: 0.5rem; }
.md-content details summary::-webkit-details-marker { display: none; }
.md-content details summary::before { content: '▶'; font-size: 0.75rem; transition: transform 0.2s; }
.md-content details[open] summary::before { transform: rotate(90deg); }
.md-content details[open] summary { border-radius: 8px 8px 0 0; }
.md-content details > *:not(summary) { padding: 0 1rem; }
.md-content details > *:last-child { padding-bottom: 1rem; }
.md-content p > details { margin: 0; }
.md-content p:has(> details) { margin: 1rem 0; }
.inline-answer { background: linear-gradient(135deg, #d4edda, #e8f4fd); padding: 0.125rem 0.5rem; border-radius: 4px; transition: opacity 0.2s; }
.inline-answer.hidden { opacity: 0; user-select: none; }
.answer-toggle-btn { display: inline-flex; align-items: center; gap: 0.5rem; background: linear-gradient(135deg, #e8f4fd, #f0e8fd); border: 1px solid var(--primary); color: var(--primary); padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-size: 0.875rem; font-weight: 600; margin: 1rem 0; }
.answer-toggle-btn:hover { background: var(--primary); color: white; }
.answer-toggle-btn svg { width: 1rem; height: 1rem; }
.letter-groups { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin: 1.5rem 0; }
.letter-group { border: 2px solid var(--border); border-radius: 8px; padding: 1rem; text-align: center; }
.letter-group.true-friends { border-color: var(--success); } .letter-group.true-friends .letters { color: var(--success); }
.letter-group.false-friends { border-color: var(--danger); } .letter-group.false-friends .letters { color: var(--danger); }
.letter-group.new-letters { border-color: var(--primary); } .letter-group.new-letters .letters { color: var(--primary); }
.letters { font-size: 1.75rem; letter-spacing: 0.3rem; }
.btn { padding: 0.75rem 1.5rem; border: none; border-radius: 8px; cursor: pointer; }
.btn-primary { background: var(--primary); color: white; }
.btn-outline { background: transparent; border: 2px solid var(--border); }
.btn-group { display: flex; gap: 1rem; justify-content: center; margin-top: 1.5rem; }
.score-display { text-align: center; padding: 1rem; background: linear-gradient(135deg, #e8f8f0, #e8f4fd); border-radius: 8px; margin-bottom: 1rem; }
.score-display .score { font-size: 2rem; font-weight: 700; color: var(--success); }
.completion-message { text-align: center; padding: 2rem; background: linear-gradient(135deg, #d4edda, #e8f4fd); border-radius: 12px; margin-top: 1rem; display: none; }
.completion-message.show { display: block; }
footer { text-align: center; padding: 2rem; color: var(--text-muted); }
@media (max-width: 768px) { .nav { flex-direction: column; gap: 1rem; } .letter-groups, .sort-groups, .quiz-options { grid-template-columns: 1fr; } .match-container { flex-direction: column; } }


/**
 * Layout styles - Navigation, page structure
 */

/* Top Navigation */
.top-nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 1.5rem;
  background: #f8f8f8;
  border-bottom: 1px solid var(--border);
  font-size: 0.875rem;
}

.top-nav a {
  color: var(--text-muted);
}

.top-nav a:hover {
  color: var(--primary);
}

.module-nav {
  display: flex;
  gap: 1rem;
}

.module-nav-link {
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
}

.module-nav-link:hover {
  background: #e8f4fd;
}

/* Main Navigation */
.nav {
  background: linear-gradient(135deg, #1a5fb4, #613583);
  color: white;
  padding: 1.5rem 2rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.nav h1 {
  font-size: 1.5rem;
}

.nav-tabs {
  display: flex;
  gap: 0.5rem;
}

.nav-tab {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.875rem;
  transition: background 0.2s;
}

.nav-tab:hover {
  background: rgba(255, 255, 255, 0.3);
}

.nav-tab.active {
  background: white;
  color: var(--primary);
}

/* Main Content */
main {
  max-width: 1000px;
  margin: 0 auto;
  padding: 2rem;
}

/* Sections */
.section {
  display: none;
}

.section.active {
  display: block;
}

/* Lesson Header */
.lesson-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 2rem;
  background: linear-gradient(135deg, #e8f4fd, #f0e8fd);
  border-radius: 12px;
}

.lesson-header h2 {
  font-size: 2rem;
  margin: 0.5rem 0;
}

/* Section Cards */
.section-intro {
  border-left: 4px solid var(--primary);
}

.section-intro h3 {
  color: var(--primary);
}

.section-topic {
  border-left: 4px solid var(--border);
}

.section-summary {
  background: linear-gradient(135deg, #f0f9ff, #e8f4fd);
  border-left: 4px solid var(--success);
}

.section-summary h3 {
  color: var(--success);
}

/* Canvas Notes */
.canvas-note {
  background: #fffbeb;
  border-left: 4px solid var(--warning);
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 0 8px 8px 0;
}

.canvas-note h4 {
  color: var(--warning);
  margin-bottom: 0.5rem;
}

/* Footer */
footer {
  text-align: center;
  padding: 2rem;
  color: var(--text-muted);
}

/* Responsive Layout */
@media (max-width: 768px) {
  .nav {
    flex-direction: column;
    gap: 1rem;
  }

  .nav h1 {
    font-size: 1.25rem;
    text-align: center;
  }

  .nav-tabs {
    flex-wrap: wrap;
    justify-content: center;
  }

  main {
    padding: 1rem;
  }

  .top-nav {
    flex-direction: column;
    gap: 0.5rem;
  }
}


/* Match Activity */
.match-container { display: flex; gap: 3rem; padding: 1rem; position: relative; }
.match-column { flex: 1; display: flex; flex-direction: column; gap: 0.75rem; }
.match-item { background: var(--card-bg); border: 2px solid var(--border); border-radius: 8px; padding: 1rem; text-align: center; font-size: 1.25rem; cursor: pointer; }
.match-item.selected { border-color: var(--primary); background: #e8f4fd; }
.match-item.matched { border-color: var(--success); background: #e8f8f0; }
.match-item.wrong { border-color: var(--danger); background: #fde8e8; }
.match-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

/* Quiz Activity */
.quiz-question { border: 1px solid var(--border); border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem; }
.quiz-question.answered { pointer-events: none; }
.quiz-question .cyrillic { font-size: 1.5rem; color: var(--primary); font-weight: 600; }
.quiz-options { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; margin-top: 1rem; }
.quiz-option { background: #f5f5f5; border: 2px solid var(--border); border-radius: 8px; padding: 1rem; cursor: pointer; text-align: center; }
.quiz-option.correct { border-color: var(--success); background: #d4edda; }
.quiz-option.wrong { border-color: var(--danger); background: #f8d7da; }
.quiz-explanation { margin-top: 1rem; padding: 1rem; background: #e8f4fd; border-radius: 8px; display: none; }
.quiz-explanation.show { display: block; }

/* True/False Activity */
.tf-statement { border: 1px solid var(--border); border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem; }
.tf-statement.answered { pointer-events: none; }
.tf-text { font-size: 1.15rem; margin-bottom: 1rem; }
.tf-buttons { display: flex; gap: 1rem; }
.tf-btn { flex: 1; background: #f5f5f5; border: 2px solid var(--border); border-radius: 8px; padding: 0.75rem 1rem; cursor: pointer; font-size: 1rem; font-weight: 500; }
.tf-btn:hover { background: #e8f4fd; border-color: var(--primary); }
.tf-btn.correct { border-color: var(--success); background: #d4edda; color: var(--success); }
.tf-btn.wrong { border-color: var(--danger); background: #f8d7da; color: var(--danger); }
.tf-explanation { margin-top: 1rem; padding: 1rem; background: #e8f4fd; border-radius: 8px; display: none; }
.tf-explanation.show { display: block; }

/* Sort Activity */
.sort-pool { background: #f5f5f5; border: 2px dashed var(--border); border-radius: 12px; padding: 1.5rem; min-height: 80px; margin-bottom: 1rem; }
.sort-items { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; }
.sort-item { background: var(--card-bg); border: 2px solid var(--border); border-radius: 8px; padding: 0.75rem 1.25rem; font-size: 1.5rem; cursor: grab; }
.sort-item.correct { border-color: var(--success); background: #e8f8f0; }
.sort-item.wrong { border-color: var(--danger); background: #fde8e8; }
.sort-groups { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
.sort-group { border: 2px solid var(--border); border-radius: 12px; padding: 1rem; min-height: 150px; }
.sort-group.drag-over { border-color: var(--primary); background: #e8f4fd; }
.sort-group h4 { font-size: 0.875rem; text-align: center; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid var(--border); }
.sort-group.true-friends h4 { color: var(--success); border-color: var(--success); }
.sort-group.false-friends h4 { color: var(--danger); border-color: var(--danger); }
.sort-group.new-letters h4 { color: var(--primary); border-color: var(--primary); }

/* Vocabulary Grid (legacy) */
.vocab-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 1rem; }
.vocab-card { border: 1px solid var(--border); border-radius: 12px; padding: 1.25rem; text-align: center; }
.vocab-card .uk { font-size: 1.75rem; font-weight: 600; color: var(--primary); }
.vocab-card .translit { color: var(--text-muted); font-style: italic; }
.vocab-card .en { font-weight: 500; margin: 0.25rem 0; }
.vocab-card .note { font-size: 0.75rem; color: #613583; background: #f0e8fd; padding: 0.25rem 0.5rem; border-radius: 4px; }

/* Vocabulary Table (book-style) */
.vocab-table-container { overflow-x: auto; }
.vocab-table { width: 100%; border-collapse: collapse; font-size: 1rem; }
.vocab-table thead { background: var(--card-bg); border-bottom: 2px solid var(--border); }
.vocab-table th { padding: 0.75rem 1rem; text-align: left; font-weight: 600; color: var(--text-muted); font-size: 0.875rem; text-transform: uppercase; letter-spacing: 0.5px; }
.vocab-table td { padding: 0.75rem 1rem; border-bottom: 1px solid var(--border); }
.vocab-table tbody tr:hover { background: #f8f9fa; }
.vocab-table .vocab-uk { font-size: 1.25rem; font-weight: 600; color: var(--primary); }
.vocab-table .vocab-translit { color: var(--text-muted); font-style: italic; }
.vocab-table .vocab-ipa { font-family: monospace; color: var(--text-muted); font-size: 0.9rem; }
.vocab-table .vocab-en { font-weight: 500; }
.vocab-table .vocab-note { font-size: 0.85rem; color: #613583; }

/* Answer Callout Blocks */
.callout { padding: 0.5rem 1rem; margin: 0.25rem 0; border-radius: 4px; }
.callout-answer { background: #e8f8f0; border-left: 3px solid var(--success); }
.callout-explanation { background: #e8f4fd; border-left: 3px solid var(--primary); color: var(--text-muted); font-style: italic; }
.callout-alt { background: #f5f5f5; border-left: 3px solid var(--border); color: var(--text-muted); }

/* Answer Block Toggle */
.answer-block { display: none; }
.answer-block.show { display: block; }
.show-answer-btn { background: #f0f0f0; border: 1px solid var(--border); border-radius: 6px; padding: 0.25rem 0.75rem; font-size: 0.8rem; cursor: pointer; color: var(--text-muted); margin: 0.25rem 0; }
.show-answer-btn:hover { background: #e5e5e5; }
.show-answer-btn.revealed { background: #e8f8f0; border-color: var(--success); color: var(--success); }

/* Fill-in Activity - Dropdown in Sentence */
.fill-container { display: flex; flex-direction: column; gap: 0.75rem; }
.fill-question { border: 1px solid var(--border); border-radius: 12px; padding: 1rem 1.5rem; }

.fill-number { font-weight: 600; color: var(--text-muted); margin-right: 0.5rem; }
.fill-sentence { font-size: 1.15rem; line-height: 1.8; }

.fill-dropdown { font-size: 1rem; padding: 0.4rem 0.6rem; border: 2px solid var(--primary); border-radius: 6px; background: #fff; color: var(--primary); font-weight: 500; cursor: pointer; min-width: 120px; }
.fill-dropdown:focus { outline: none; box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2); }
.fill-dropdown.correct { border-color: var(--success); background: #e8f8f0; color: var(--success); }
.fill-dropdown.wrong { border-color: var(--danger); background: #fde8e8; color: var(--danger); }

.fill-feedback { margin-top: 0.5rem; font-weight: 500; }
.fill-feedback .correct-text { color: var(--success); }
.fill-feedback .wrong-text { color: var(--danger); }
.btn-sm { padding: 0.5rem 1rem; font-size: 0.875rem; }

/* Order/Unjumble Activity */
.order-container { display: flex; flex-direction: column; gap: 1rem; }
.order-items { display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem; }
.order-item { background: var(--card-bg); border: 2px solid var(--border); border-radius: 8px; padding: 1rem; display: flex; align-items: center; gap: 1rem; cursor: grab; user-select: none; }
.order-item:active { cursor: grabbing; }
.order-item.dragging { opacity: 0.5; }
.order-item.correct { border-color: var(--success); background: #e8f8f0; }
.order-item.wrong { border-color: var(--danger); background: #fde8e8; }
.order-handle { color: var(--text-muted); font-size: 1.25rem; }
.order-text { font-size: 1.1rem; }

/* Unjumble Activity - Drag and Drop */
.unjumble-question { border: 1px solid var(--border); border-radius: 12px; padding: 1rem 1.5rem; margin-bottom: 0.75rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; }
.unjumble-question.answered .unjumble-word { cursor: default; }
.unjumble-question.correct { border-color: var(--success); background: #f8fff8; }
.unjumble-question.wrong { border-color: var(--danger); background: #fff8f8; }

.unjumble-number { font-weight: 600; color: var(--text-muted); min-width: 2rem; }

.unjumble-word-row { display: flex; flex-wrap: wrap; gap: 0.5rem; flex: 1; min-height: 42px; padding: 0.25rem; border-radius: 8px; background: #f8f9fa; }
.unjumble-word-row.correct { background: #e8f8f0; }
.unjumble-word-row.wrong { background: #fde8e8; }

.unjumble-word { background: var(--primary); color: white; border-radius: 6px; padding: 0.5rem 0.75rem; font-size: 1rem; cursor: grab; user-select: none; transition: transform 0.1s, box-shadow 0.1s; }
.unjumble-word:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
.unjumble-word:active { cursor: grabbing; }
.unjumble-word.dragging { opacity: 0.5; transform: scale(1.05); }

.unjumble-word.touch-clone { position: fixed; z-index: 1000; pointer-events: none; box-shadow: 0 8px 16px rgba(0,0,0,0.2); }

.unjumble-actions { display: flex; gap: 0.5rem; }
.unjumble-feedback { width: 100%; padding: 0.5rem 0 0 2.5rem; display: none; }
.unjumble-feedback.show { display: block; }
.unjumble-feedback .correct-text { color: var(--success); font-weight: 600; }
.unjumble-feedback .wrong-text { color: var(--danger); }
.unjumble-feedback .translation { color: var(--text-muted); font-style: italic; margin-left: 0.5rem; }

/* Order Sentence Activity - Sentence reordering with unjumble-style UI */
.order-sequence { display: flex; flex-direction: column; align-items: stretch; }
.order-sentence-row { display: flex; flex-direction: column; flex-wrap: nowrap; gap: 0.5rem; min-height: auto; padding: 0.5rem; flex: none; width: 100%; }
.order-sentence-item { background: var(--primary); color: white; border-radius: 8px; padding: 0.75rem 1rem; font-size: 1rem; cursor: grab; user-select: none; display: flex; align-items: center; gap: 0.75rem; transition: transform 0.1s, box-shadow 0.1s; }
.order-sentence-item:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
.order-sentence-item:active { cursor: grabbing; }
.order-sentence-item.dragging { opacity: 0.5; transform: scale(1.02); }
.order-sentence-item.correct { background: var(--success); }
.order-sentence-item.wrong { background: var(--danger); }
.order-sentence-item.touch-clone { position: fixed; z-index: 1000; pointer-events: none; box-shadow: 0 8px 16px rgba(0,0,0,0.2); max-width: 90vw; }
.order-num { background: rgba(255,255,255,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; min-width: 1.5rem; text-align: center; }
.order-sentence-text { flex: 1; }
.order-feedback { width: 100%; padding: 0.5rem 0; display: none; }
.order-feedback.show { display: block; }
.order-feedback .correct-text { color: var(--success); font-weight: 600; }
.order-feedback .wrong-text { color: var(--danger); }

/* Order Card Activity - New class names for classic order */
.order-items-wrapper { display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem; }
.order-sentence-card { background: var(--primary); color: white; border-radius: 8px; padding: 0.75rem 1rem; font-size: 1rem; cursor: grab; user-select: none; display: flex; align-items: center; gap: 0.75rem; transition: transform 0.1s, box-shadow 0.1s; }
.order-sentence-card:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
.order-sentence-card:active { cursor: grabbing; }
.order-sentence-card.dragging { opacity: 0.5; transform: scale(1.02); }
.order-sentence-card.correct { background: var(--success); }
.order-sentence-card.wrong { background: var(--danger); }
.order-card-num { background: rgba(255,255,255,0.3); padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; min-width: 1.5rem; text-align: center; }
.order-card-text { flex: 1; }
.order-buttons { margin-top: 0.5rem; }

/* Select Activity - Multi-choice checkboxes */
.select-container { display: flex; flex-direction: column; gap: 1rem; }
.select-question { border: 1px solid var(--border); border-radius: 12px; padding: 1.25rem; display: flex; gap: 0.75rem; }
.select-question.answered .select-checkbox { pointer-events: none; }
.select-number { font-weight: 600; color: var(--text-muted); min-width: 2rem; }
.select-content { flex: 1; }
.select-prompt { font-size: 1.1rem; font-weight: 500; margin-bottom: 0.75rem; }
.select-options { display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 0.75rem; }
.select-option { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 6px; cursor: pointer; transition: background 0.15s; }
.select-option:hover { background: #f5f5f5; }
.select-option.correct { background: #d4edda; }
.select-option.correct-unchecked { background: #f8f9fa; }
.select-option.wrong { background: #f8d7da; }
.select-option.missed { background: #fff3cd; border: 1px dashed var(--warning); }
.select-checkbox { width: 1.25rem; height: 1.25rem; cursor: pointer; }
.select-text { font-size: 1rem; }
.select-check { margin-top: 0.5rem; }
.select-feedback { margin-top: 0.75rem; display: none; }
.select-feedback.show { display: block; }
.select-feedback .correct-text { color: var(--success); font-weight: 600; }
.select-feedback .wrong-text { color: var(--danger); }

  </style>
</head>
<body>
  
  <div class="top-nav">
    <a href="../index.html">← l2-uk-en Curriculum</a>
    <div class="module-nav">
      <a href="module-26.html" class="module-nav-link">← Module 26</a>
      <a href="index.html" class="module-nav-link">B2 Index</a>
      <a href="module-28.html" class="module-nav-link">Module 28 →</a>
    </div>
  </div>
  <nav class="nav">
    <h1>Module 27: History: Kyivan Rus I</h1>
    <div class="nav-tabs">
      <button class="nav-tab active" data-section="lesson">Lesson</button>
      <button class="nav-tab" data-section="activity-0">1. Quiz</button>
      <button class="nav-tab" data-section="vocab">Vocab</button>
    </div>
  </nav>
  <main>
    
    <section id="lesson" class="section active">
      <div class="lesson-header">
        <span class="level-badge">B2 · B2.2</span>
        <h2 style="font-size:2rem;margin:0.5rem 0">History: Kyivan Rus I</h2>
        <p style="color:var(--text-muted)">Київська Русь I: Виникнення</p>
      </div>
      
    <div class="card section-content">
      <h3>Зміст уроку</h3>
      <div class="md-content"><h2 id="">Вступ: Найбільша крадіжка в історії</h2>
<p>Уявіть, що хтось вкрав вашу історію.</p>
<p>Не просто якусь частину — а <em>всю</em> вашу історію. Ваших предків. Ваших героїв. Ваші храми, книги, традиції. І почав стверджувати, що це все — його.</p>
<p>Саме це сталося з Київською Руссю.</p>
<p>У 1721 році Петро I, московський цар, вирішив, що йому потрібна нова назва для своєї держави. Стара назва — «Московія» або «Московське царство» — звучала занадто… провінційно. Він хотів імперію. Він хотів легітимність. Він хотів стародавню історію.</p>
<p>І він просто <em>взяв</em> її.</p>
<p>Петро оголосив, що відтепер Московія називається «Російська імперія», а московити — «росіяни». А що таке «Русь»? Ну, це ж очевидно — «Русь» і «Росія» — одне й те саме, правда? Отже, Київ — це «російське» місто, а Київська Русь — «колиска російської державності».</p>
<p>Один підпис — і тисяча років української історії стала «російською».</p>
<p>Це не перебільшення. Це буквально те, що сталося. І наслідки цієї крадіжки ми відчуваємо досі — кожного разу, коли російський пропагандист каже, що «українці — це просто росіяни, які забули, хто вони».</p>
<p>Сьогодні ми відновлюємо правду. Ми розповімо справжню історію Київської Русі — української середньовічної держави, яку Москва так відчайдушно намагається привласнити.</p>
<hr />
<h2 id="-1">Розминка: Перевірте свої знання</h2>
<p>Перш ніж продовжити — маленький тест. Що з цього правда?</p>
<table>
<thead>
<tr>
<th>Твердження</th>
<th>Ваша відповідь</th>
</tr>
</thead>
<tbody>
<tr>
<td>Москва була столицею Київської Русі</td>
<td>Так / Ні</td>
</tr>
<tr>
<td>«Русь» і «Росія» — синоніми</td>
<td>Так / Ні</td>
</tr>
<tr>
<td>Київ заснований раніше за Москву</td>
<td>Так / Ні</td>
</tr>
<tr>
<td>Московити завжди називали себе «русами»</td>
<td>Так / Ні</td>
</tr>
</tbody>
</table>
<p><strong>Правильні відповіді:</strong></p>
<ul>
<li>Москва була столицею Русі? <strong>Ні.</strong> (Москва заснована через 265 років після Києва!)</li>
<li>«Русь» і «Росія» — синоніми? <strong>Ні.</strong> (Це різні поняття)</li>
<li>Київ заснований раніше за Москву? <strong>Так.</strong> (882 vs 1147)</li>
<li>Московити завжди називали себе «русами»? <strong>Ні.</strong> (Лише з XVIII століття)</li>
</ul>
<p>Якщо ви помилилися — не хвилюйтеся. Саме для цього ми тут.</p>
<hr />
<h2 id="1">Частина 1: Що таке «Русь»? Три теорії</h2>
<p>Почнемо з головного питання: звідки взагалі взялася назва «Русь»?</p>
<p>Це питання археологи та лінгвісти обговорюють уже понад століття. І є три основні теорії.</p>
<h3 id="1-1">Теорія 1: Норманська (скандинавська)</h3>
<p>Ця теорія стверджує, що «Русь» походить від фінського слова «ruotsi», яким фіни називали скандинавів. А скандинави (варяги) були купцями та воїнами, які мандрували річками від Балтики до Чорного моря.</p>
<p><strong>Докази:</strong> У скандинавських сагах згадується «Garðaríki» (Країна городів) — так вікінги називали землі на сході. Також багато імен перших київських князів — явно скандинавські: Олег (Helgi), Ігор (Ingvar), Ольга (Helga).</p>
<p><strong>Контраргумент:</strong> Навіть якщо назва прийшла від варягів, <em>населення</em> було слов'янським. Варяги — це верхівка, еліта, яка швидко асимілювалася. Вже внук Рюрика — Святослав — мав слов'янське ім'я.</p>
<h3 id="2">Теорія 2: Слов'янська (від річки Рось)</h3>
<p>Ця теорія пропонує простіше пояснення: «Русь» — від річки Рось, що впадає в Дніпро неподалік від Києва. Річка давала назву племенам, які жили на її берегах, а потім — усій державі.</p>
<p><strong>Докази:</strong> Багато українських топонімів пов'язані з коренем «рос/рус»: Рось, Росава, Росія (село в Сумській області, не плутати з державою-агресором).</p>
<p><strong>Контраргумент:</strong> Лінгвісти сперечаються, чи була річка названа на честь людей, чи люди — на честь річки.</p>
<h3 id="3">Теорія 3: Іранська (сарматська)</h3>
<p>Найекзотичніша теорія пов'язує «Русь» із давньоіранським словом «ruxs» або «roxs», що означає «світлий, сяючий». Сармати, іраномовний народ, який жив у степах України до слов'ян, могли залишити цю назву.</p>
<p><strong>Докази:</strong> Деякі античні автори згадують «роксоланів» (roxolani) — буквально «світлих аланів». Можливо, цей етнонім перейшов до слов'ян.</p>
<hr />
<blockquote>
  <p><strong>Чи знали ви?</strong></p>
  <p>У XIX столітті «норманська теорія» стала політичною зброєю. Деякі російські історики використовували її, щоб стверджувати: «Слов'яни не могли самі створити державу — їм потрібні були германці». Це відверто расистський аргумент. Українські історики відповідали: навіть якщо Рюрик був скандинавом, держава будувалася слов'янами на слов'янській землі слов'янською мовою.</p>
  <p>Сьогодні більшість серйозних істориків погоджуються: <em>походження</em> назви — менш важливе, ніж <em>реальність</em> держави. А реальність така: Київська Русь була слов'янською державою зі столицею в Києві. Крапка.</p>
</blockquote>
<hr />
<h2 id="2-1">Частина 2: Як виникла Київська Русь</h2>
<p>Тепер — до фактів. Як саме постала ця держава?</p>
<h3 id="862">Рюрик і варяги (862)</h3>
<p>Згідно з «Повістю минулих літ» — найдавнішим українським літописом — слов'янські та фінські племена на півночі постійно воювали між собою. Втомившись від чвар, вони вирішили запросити зовнішнього правителя:</p>
<p><em>«Земля наша велика і багата, але порядку в ній немає. Прийдіть княжити і володіти нами.»</em></p>
<p>Так у 862 році Рюрик прийшов до Новгорода і став першим князем. Чи це історичний факт, чи легенда — досі дискутується. Але важливо інше: Рюрик правив <em>Новгородом</em>, не Києвом.</p>
<h3 id="882">Олег і створення держави (882)</h3>
<p>Справжнім засновником Київської Русі вважається Олег — родич (можливо, шурин) Рюрика. У 882 році Олег зібрав військо і рушив на південь — до Києва.</p>
<p>У Києві на той час правили Аскольд і Дір — теж варяги. Олег хитрістю вбив їх і захопив місто. А потім сказав слова, які стали символом української державності:</p>
<p><em>«Хай буде Київ матір'ю міст руських!»</em></p>
<p>Не Новгород. Не Ладога. Київ. Саме Київ став центром нової держави. І залишався ним наступні 350 років.</p>
<hr />
<blockquote>
  <p><strong>Міф vs Факт</strong></p>
  <p>❌ <strong>Міф:</strong> «Русь починалася з Новгорода, тому її спадкоємиця — Москва (яка ближче до Новгорода).»</p>
  <p>✅ <strong>Факт:</strong> Рюрик дійсно спочатку правив у Новгороді, але <em>державу</em> створив Олег, і він одразу проголосив столицею <em>Київ</em>. Новгород залишався важливим містом, але завжди був підпорядкований Києву. А Москви взагалі не існувало ще 265 років. Говорити, що Москва — «спадкоємиця Русі», бо Новгород був на півночі — це як казати, що Румунія — спадкоємиця Римської імперії, бо теж починається на «Р».</p>
</blockquote>
<hr />
<h3 id="-2">Хронологія перших правителів</h3>
<table>
<thead>
<tr>
<th>Роки</th>
<th>Правитель</th>
<th>Головне</th>
</tr>
</thead>
<tbody>
<tr>
<td>862-879</td>
<td>Рюрик</td>
<td>Прийшов до Новгорода</td>
</tr>
<tr>
<td>879-912</td>
<td>Олег</td>
<td>Захопив Київ, створив державу</td>
</tr>
<tr>
<td>912-945</td>
<td>Ігор</td>
<td>Походи на Візантію, загинув від древлян</td>
</tr>
<tr>
<td>945-964</td>
<td>Ольга</td>
<td>Регентша при малому Святославі</td>
</tr>
<tr>
<td>964-972</td>
<td>Святослав</td>
<td>Великий воїн, походи на схід</td>
</tr>
</tbody>
</table>
<h3 id="-3">Олег Віщий: перший геополітик</h3>
<p>Олег правив 30 років, і за цей час перетворив Русь на серйозну силу. У 907 році він здійснив неймовірний похід на Константинополь (Царгород) — столицю Візантійської імперії, наймогутнішої держави тогочасного світу.</p>
<p>За легендою, Олег прибив свій щит до воріт Царгорода — символ перемоги. Візантійці погодились платити данину і підписали вигідний для Русі торговий договір.</p>
<p>Чи прибивав Олег щит насправді? Ми не знаємо. Але договір із Візантією — це історичний факт. Текст договору зберігся в літописах.</p>
<hr />
<blockquote>
  <p><strong>Чи знали ви?</strong></p>
  <p>Прізвисько «Віщий» Олег отримав за свою здатність передбачати події. Але помер він, за легендою, від того, чого не передбачив — від укусу змії, яка вилізла з черепа його мертвого коня. Ця історія стала основою для знаменитої «Пісні про віщого Олега» Олександра Пушкіна — одного з небагатьох творів російського поета, де він <em>не</em> намагається привласнити українську історію.</p>
</blockquote>
<hr />
<h3 id="-4">Княгиня Ольга: перша християнка</h3>
<p>Ольга — одна з найцікавіших постатей ранньої Русі. Після загибелі її чоловіка Ігоря від рук древлян (вони розірвали його між двома деревами за надмірне збирання данини), Ольга помстилася так жорстоко, що це стало легендою.</p>
<p>Спочатку вона закопала живцем древлянських послів. Потім спалила другу групу послів у лазні. Потім влаштувала тризну (поминальний бенкет) біля древлянської столиці Іскоростеня — і вирізала п'ять тисяч п'яних древлян. А на завершення — спалила саме місто за допомогою горобців та голубів, до лапок яких прив'язали тліючу сірку.</p>
<p>Після такої помсти Ольга… прийняла християнство. У Константинополі. Вона стала першою правителькою Русі, яка хрестилася — задовго до офіційного хрещення Русі її онуком Володимиром.</p>
<hr />
<blockquote>
  <p><strong>Чи знали ви?</strong></p>
  <p>Ольга — єдина жінка в історії Русі, яка канонізована як <em>рівноапостольна</em> святая. Цей титул означає, що її внесок у поширення християнства прирівнюється до внеску апостолів. В усій історії християнства цей титул отримали лише п'ятеро жінок — і Ольга серед них.</p>
</blockquote>
<hr />
<h2 id="3-1">Частина 3: Чому «Русь» — це Україна, не Росія</h2>
<p>А тепер — найважливіша частина. Чому ми категорично стверджуємо, що Київська Русь — українська, а не російська?</p>
<h3 id="1-2">Аргумент 1: Географія</h3>
<p>Це найпростіший аргумент. Подивіться на карту:</p>
<ul>
<li><strong>Київ</strong> (столиця Русі) — сьогодні столиця України</li>
<li><strong>Чернігів</strong> (друге за значенням місто) — в Україні</li>
<li><strong>Переяслав</strong> (місто княжих з'їздів) — в Україні</li>
<li><strong>Галич</strong> (столиця Галицького князівства) — в Україні</li>
</ul>
<p>А де Москва? Москву <em>засновано в 1147 році</em> — через 265 років після створення Київської Русі. І навіть тоді це було маленьке село на периферії. Москва <em>ніколи</em> не була частиною власне Київської Русі — вона входила до Володимиро-Суздальського князівства, яке відокремилось від Києва.</p>
<h3 id="2-2">Аргумент 2: Мова</h3>
<p>Мова Київської Русі — давньоруська (або давньоукраїнська, як її називають українські лінгвісти). Сучасні лінгвістичні дослідження показують, що:</p>
<ul>
<li>Давньоруська мова <em>найближча</em> до сучасної української</li>
<li>Російська мова сформувалася значно пізніше, під впливом фіно-угорських та тюркських мов</li>
<li>Багато слів, які збереглися в українській, зникли з російської</li>
</ul>
<p>Наприклад, українське слово «працювати» — це давньоруське «працювати». Російське «работать» — від слова «раб» (робити роботу як раб). Яка мова ближча до оригіналу?</p>
<h3 id="3-2">Аргумент 3: Культура</h3>
<p>Культурні пам'ятки Київської Русі — всі в Україні:</p>
<ul>
<li><strong>Софія Київська</strong> (1037) — найважливіший храм Русі, стоїть у Києві</li>
<li><strong>Києво-Печерська лавра</strong> — духовний центр Русі, у Києві</li>
<li><strong>Десятинна церква</strong> — перша кам'яна церква Русі, була в Києві</li>
</ul>
<p>А що в Москві? <em>Нічого</em> з часів Київської Русі. Бо Москви тоді <em>не існувало</em>.</p>
<h3 id="4">Аргумент 4: Самоназва</h3>
<p>Ось найцікавіший факт: московити <em>не називали себе «русами»</em> до XVIII століття!</p>
<p>Коли в XV-XVI століттях московські правителі почали претендувати на «руську» спадщину, вони не говорили «ми — Русь». Вони говорили «ми — спадкоємці Русі», що зовсім інше.</p>
<p>Навіть у назвах: Московія, Московське царство, московити — не «Русь», не «руси». Лише Петро I у 1721 році <em>примусово</em> перейменував державу на «Російську імперію».</p>
<hr />
<blockquote>
  <p><strong>Міф vs Факт</strong></p>
  <p>❌ <strong>Міф:</strong> «Українці та росіяни — один народ, тому Русь — спільна спадщина.»</p>
  <p>✅ <strong>Факт:</strong> Ця теза — основа путінської пропаганди, яку він виклав у статті 2021 року. Але історичні факти говорять інше: українці та росіяни — різні народи з різною історією, мовою та культурою. Так, є спільне коріння — як у французів та італійців є спільне римське коріння. Але це не робить Францію та Італію «одним народом». Русь — це українська спадщина. Москва може мати свою історію — Московії, яка виникла пізніше і розвивалася окремо.</p>
</blockquote>
<hr />
<h2 id="4-1">Частина 4: Крадіжка історії — як це сталося</h2>
<p>Як московитам вдалося «вкрасти» Русь? Це не сталося за одну ніч — це був довгий процес.</p>
<h3 id="1xvxvii">Крок 1: Претензії московських царів (XV-XVII ст.)</h3>
<p>Після падіння Києва від монголів (1240) різні князівства претендували на «руську» спадщину. Московські князі — теж. Вони почали називати себе «государями всея Русі», хоча <em>фактично</em> більшість руських земель їм не належала.</p>
<h3 id="21721">Крок 2: Перейменування Московії (1721)</h3>
<p>Петро I офіційно перейменував Московію на «Російську імперію», а московитів — на «росіян». Це був маркетинговий хід: «Росія» звучить як «Русь», що створює ілюзію спадкоємності.</p>
<h3 id="3xviiixix">Крок 3: Переписування історії (XVIII-XIX ст.)</h3>
<p>Російські історики почали систематично переписувати історію. Вони:</p>
<ul>
<li>Називали Київську Русь «Древнерусское государство» (давньоруська держава), ігноруючи слово «Київ»</li>
<li>Стверджували, що «руси» = «росіяни»</li>
<li>Применшували роль Києва і перебільшували роль Новгорода та Москви</li>
</ul>
<h3 id="4xx">Крок 4: Радянська історіографія (XX ст.)</h3>
<p>СРСР продовжив цю традицію. У радянських підручниках Київська Русь подавалась як «спільна колиска» трьох «братніх народів» — росіян, українців та білорусів. При цьому «старший брат» (росіяни) чомусь успадкував <em>всю</em> спадщину.</p>
<h3 id="5xxi">Крок 5: Путінська пропаганда (XXI ст.)</h3>
<p>Сьогодні Путін використовує ці міфи для виправдання війни. Його логіка: «Якщо Київська Русь — російська, то Київ — російське місто. А отже, Україна не має права на існування».</p>
<p>Саме тому <em>знання правдивої історії — це акт спротиву</em>.</p>
<hr />
<blockquote>
  <p><strong>Чи знали ви?</strong></p>
  <p>У 2021 році Путін опублікував статтю «Про історичну єдність росіян та українців», де виклав усі ці міфи. Українські історики назвали статтю «маніфестом імперіалізму» та «історичною фальсифікацією». Через рік Росія почала повномасштабне вторгнення. Крадіжка історії — це не академічна дискусія. Це підготовка до війни.</p>
</blockquote>
<hr />
<h2 id="-5">Термінологія: Важливі слова</h2>
<table>
<thead>
<tr>
<th>Термін</th>
<th>Переклад</th>
<th>Пояснення</th>
</tr>
</thead>
<tbody>
<tr>
<td>Русь</td>
<td>Rus</td>
<td>Історична назва держави та народу</td>
</tr>
<tr>
<td>руси / русини</td>
<td>Ruthenians</td>
<td>Мешканці Русі (НЕ «росіяни»!)</td>
</tr>
<tr>
<td>руський (давньоукр.)</td>
<td>Ruthenian</td>
<td>Прикметник від «Русь», НЕ «російський»</td>
</tr>
<tr>
<td>давньоруський</td>
<td>Old Rus / Old Ukrainian</td>
<td>Мова та культура Русі</td>
</tr>
<tr>
<td>Московія</td>
<td>Muscovy</td>
<td>Московське царство до 1721 р.</td>
</tr>
<tr>
<td>московити</td>
<td>Muscovites</td>
<td>Мешканці Московії до 1721 р.</td>
</tr>
<tr>
<td>варяги</td>
<td>Varangians</td>
<td>Скандинавські воїни-торговці</td>
</tr>
</tbody>
</table>
<p><strong>Важливо:</strong> Англійською часто плутають «Russian» (російський) і «Ruthenian» (руський). Це <em>різні</em> слова! Коли йдеться про Київську Русь, правильний переклад — «Ruthenian» або «Rus'», НЕ «Russian».</p>
<hr />
<h2 id="-6">Практика</h2>
<h3 id="1-3">Завдання 1: Заповніть пропуски</h3>
<ol>
<li><p>Олег проголосив Київ «___ містам руським».</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-0', this)">Показати відповідь</button><div class="answer-block" id="ans-0"><div class="callout callout-answer" data-callout="answer"><strong>матір'ю</strong></div></div>
<ol start="2">
<li><p>Москву засновано в ___ році, через 265 років після Києва.</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-1', this)">Показати відповідь</button><div class="answer-block" id="ans-1"><div class="callout callout-answer" data-callout="answer"><strong>1147</strong></div></div>
<ol start="3">
<li><p>Петро I перейменував Московію на ___ імперію.</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-2', this)">Показати відповідь</button><div class="answer-block" id="ans-2"><div class="callout callout-answer" data-callout="answer"><strong>Російську</strong></div></div>
<ol start="4">
<li><p>Давньоруська мова найближча до сучасної ___.</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-3', this)">Показати відповідь</button><div class="answer-block" id="ans-3"><div class="callout callout-answer" data-callout="answer"><strong>української</strong></div></div>
<ol start="5">
<li><p>Софію Київську збудовано в ___ році.</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-4', this)">Показати відповідь</button><div class="answer-block" id="ans-4"><div class="callout callout-answer" data-callout="answer"><strong>1037</strong></div></div>
<h3 id="2-3">Завдання 2: Правда чи міф?</h3>
<table>
<thead>
<tr>
<th>Твердження</th>
<th>П / М</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. Москва була столицею Київської Русі.</td>
<td><strong>М</strong></td>
</tr>
<tr>
<td>2. Олег Віщий захопив Київ у 882 році.</td>
<td><strong>П</strong></td>
</tr>
<tr>
<td>3. Московити завжди називали себе «русами».</td>
<td><strong>М</strong></td>
</tr>
<tr>
<td>4. Ольга — перша правителька Русі, яка хрестилася.</td>
<td><strong>П</strong></td>
</tr>
<tr>
<td>5. «Русь» і «Росія» — історично одне й те саме.</td>
<td><strong>М</strong></td>
</tr>
</tbody>
</table>
<h3 id="3-3">Завдання 3: Перекладіть (використовуйте пасив де доречно)</h3>
<ol>
<li><p>Kyiv was founded centuries before Moscow.</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-5', this)">Показати відповідь</button><div class="answer-block" id="ans-5"><div class="callout callout-answer" data-callout="answer"><strong>Київ засновано за століття до Москви.</strong></div></div>
<ol start="2">
<li><p>The myth that Russia inherited Rus is false.</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-6', this)">Показати відповідь</button><div class="answer-block" id="ans-6"><div class="callout callout-answer" data-callout="answer"><strong>Міф про те, що Росія успадкувала Русь, — хибний.</strong></div></div>
<ol start="3">
<li><p>The treaty with Byzantium was signed by Oleg.</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-7', this)">Показати відповідь</button><div class="answer-block" id="ans-7"><div class="callout callout-answer" data-callout="answer"><strong>Договір із Візантією було підписано Олегом.</strong></div></div>
<ol start="4">
<li><p>Sophia Cathedral was built in 1037.</p></li>
</ol>
<button class="show-answer-btn" onclick="toggleAnswer('ans-8', this)">Показати відповідь</button><div class="answer-block" id="ans-8"><div class="callout callout-answer" data-callout="answer"><strong>Софію Київську збудовано в 1037 році.</strong></div></div>
<hr />
<h2 id="-7">Продукція</h2>
<h3 id="-8">Обговоріть</h3>
<ol>
<li><p>Чому Росія так відчайдушно намагається привласнити історію Русі? Яка в цьому вигода?</p></li>
<li><p>Як імперські міфи використовуються для виправдання війни? Наведіть приклади.</p></li>
<li><p>Що означає «деколонізація історії»? Як ви можете долучитися до цього процесу?</p></li>
</ol>
<h3 id="150200">Напишіть (150-200 слів)</h3>
<p>Уявіть, що ви пояснюєте іноземцю, чому Київська Русь — українська, а не російська держава. Напишіть короткий текст із трьома головними аргументами.</p>
<hr />
<hr />
<hr /></div>
    </div>
  
      
    <div class="card section-summary">
      <h3>📋 Summary</h3>
      <div class="md-content"><h2 id="">Головні факти</h2>
<table>
<thead>
<tr>
<th>Факт</th>
<th>Деталі</th>
</tr>
</thead>
<tbody>
<tr>
<td>Столиця Русі</td>
<td>Київ (з 882 року)</td>
</tr>
<tr>
<td>Заснування Москви</td>
<td>1147 рік (265 років пізніше!)</td>
</tr>
<tr>
<td>Мова Русі</td>
<td>Давньоруська (найближча до української)</td>
</tr>
<tr>
<td>Культурні пам'ятки</td>
<td>Софія Київська, Лавра — усі в Україні</td>
</tr>
<tr>
<td>«Перейменування»</td>
<td>1721: Московія → Російська імперія</td>
</tr>
</tbody>
</table>
<h2 id="vs">Імперський міф vs Правда</h2>
<table>
<thead>
<tr>
<th>Міф</th>
<th>Правда</th>
</tr>
</thead>
<tbody>
<tr>
<td>«Русь = Росія»</td>
<td>Русь — українська спадщина</td>
</tr>
<tr>
<td>«Один народ»</td>
<td>Українці та росіяни — різні народи</td>
</tr>
<tr>
<td>«Москва — спадкоємиця»</td>
<td>Москва виникла через 265 років</td>
</tr>
<tr>
<td>«Спільна колиска»</td>
<td>Колиска стояла в Києві</td>
</tr>
</tbody>
</table>
<hr />
<blockquote>
  <p><strong>Чому це важливо</strong></p>
  <p>Знання правдивої історії — це не просто академічна вправа. Це спротив. Коли ви знаєте, що Київська Русь — українська держава, ви позбавляєте Росію головного аргументу для агресії. Коли ви розповідаєте цю правду іншим, ви боретеся з імперською пропагандою.</p>
  <p><em>Русь — це Україна. Київ — наша столиця. Ця історія — наша.</em></p>
  <p><strong>Слава Україні!</strong></p>
</blockquote>
<hr />
<h2 id="-1">Наступний урок</h2>
<p>У наступному модулі ми продовжимо історію Київської Русі: розквіт держави за Володимира Великого та Ярослава Мудрого, хрещення Русі, «Руська Правда» — перший збірник законів.</p></div>
    </div>
  
      <div class="btn-group">
        <button class="btn btn-primary" onclick="showSection('activity-0')">Activities →</button>
      </div>
    </section>
  
    
    <section id="activity-0" class="section"><div class="card"><h3>Київська Русь — факти та міфи</h3>
      <div class="score-display"><span class="score"><span id="activity-0-score">0</span>/8</span></div>
      <div id="activity-0-container"></div>
      <div class="completion-message" id="activity-0-complete"><h3>Complete!</h3></div>
      <div class="btn-group"><button class="btn btn-outline" onclick="resetActivity('activity-0')">Reset</button><button class="btn btn-primary" onclick="showSection('vocab')">Next →</button></div>
    </div></section>
    
    <section id="vocab" class="section">
      <div class="card">
        <h3>Словник (15)</h3>
        <div class="vocab-table-container">
          <table class="vocab-table">
            <thead><tr>
    <th>Слово</th>
    
    <th>IPA</th>
    <th>Переклад</th>
    <th>Примітка</th>
  </tr></thead>
            <tbody><tr><td class="vocab-uk">Русь</td><td class="vocab-ipa">/rusʲ/</td><td class="vocab-en">Rus</td><td class="vocab-note">Київська Русь — українська держава.</td></tr><tr><td class="vocab-uk">русини</td><td class="vocab-ipa">/ruˈsɪnɪ/</td><td class="vocab-en">Ruthenians</td><td class="vocab-note">Русини — мешканці Русі.</td></tr><tr><td class="vocab-uk">варяги</td><td class="vocab-ipa">/wɑˈrʲaɦɪ/</td><td class="vocab-en">Varangians</td><td class="vocab-note">Варяги торгували по річках.</td></tr><tr><td class="vocab-uk">племена</td><td class="vocab-ipa">/plɛˈmɛnɑ/</td><td class="vocab-en">tribes</td><td class="vocab-note">Слов&#039;янські племена об&#039;єдналися.</td></tr><tr><td class="vocab-uk">заснувати</td><td class="vocab-ipa">/zɑsnuˈwɑtɪ/</td><td class="vocab-en">to found (pf)</td><td class="vocab-note">Олег заснував державу зі столицею в Києві.</td></tr><tr><td class="vocab-uk">об&#039;єднати</td><td class="vocab-ipa">/ɔbˈjɛdnɑtɪ/</td><td class="vocab-en">to unite (pf)</td><td class="vocab-note">Він об&#039;єднав різні племена.</td></tr><tr><td class="vocab-uk">захопити</td><td class="vocab-ipa">/zɑxɔˈpɪtɪ/</td><td class="vocab-en">to capture (pf)</td><td class="vocab-note">Олег захопив Київ у 882 році.</td></tr><tr><td class="vocab-uk">правити</td><td class="vocab-ipa">/prɑˈwɪtɪ/</td><td class="vocab-en">to rule (impf)</td><td class="vocab-note">Ольга правила як регентша.</td></tr><tr><td class="vocab-uk">спадщина</td><td class="vocab-ipa">/ˈspɑdʃt͡ʃɪnɑ/</td><td class="vocab-en">heritage, legacy</td><td class="vocab-note">Русь — українська спадщина.</td></tr><tr><td class="vocab-uk">спадкоємність</td><td class="vocab-ipa">/spɑdkɔˈjɛmnʲistʲ/</td><td class="vocab-en">succession</td><td class="vocab-note">Московські претензії на спадкоємність — хибні.</td></tr><tr><td class="vocab-uk">імперія</td><td class="vocab-ipa">/ʲimˈpɛrʲijɑ/</td><td class="vocab-en">empire</td><td class="vocab-note">Російська імперія виникла в 1721 році.</td></tr><tr><td class="vocab-uk">розвінчати</td><td class="vocab-ipa">/rɔzwʲinˈtʃɑtɪ/</td><td class="vocab-en">to debunk (pf)</td><td class="vocab-note">Розвінчати імперські міфи.</td></tr><tr><td class="vocab-uk">привласнити</td><td class="vocab-ipa">/prɪwˈlɑsnɪtɪ/</td><td class="vocab-en">to appropriate (pf)</td><td class="vocab-note">Росія намагається привласнити Русь.</td></tr><tr><td class="vocab-uk">перейменувати</td><td class="vocab-ipa">/pɛrɛjmɛnuˈwɑtɪ/</td><td class="vocab-en">to rename (pf)</td><td class="vocab-note">Петро I перейменував Московію.</td></tr><tr><td class="vocab-uk">фальсифікація</td><td class="vocab-ipa">/fɑlʲsɪfʲiˈkɑt͡sʲijɑ/</td><td class="vocab-en">falsification</td><td class="vocab-note">Історична фальсифікація — злочин.</td></tr></tbody>
          </table>
        </div>
      </div>
      
      <div class="btn-group">
        <button class="btn btn-primary" onclick="showSection('lesson')">← Back to Lesson</button>
      </div>
    </section>
  </main><footer>Module 27 · curricula-opus</footer>
  <script>

    const activitiesData = [{"id":"activity-0","type":"quiz","title":"Київська Русь — факти та міфи","data":{"type":"quiz","questions":[{"question":"Коли Олег захопив Київ і проголосив його столицею Русі?","options":["у 862 році","у 882 році","у 1147 році"],"correctIndex":1,"explanation":"862 — прихід Рюрика до Новгорода. 1147 — заснування Москви."},{"question":"Москву засновано:","options":["до Київської Русі","одночасно з Києвом","через 265 років після Києва"],"correctIndex":2,"explanation":"Київ — 882, Москва — 1147."},{"question":"Петро I перейменував Московію на Російську імперію:","options":["у X столітті","у XV столітті","у 1721 році (XVIII ст.)"],"correctIndex":2,"explanation":"Це був маркетинговий хід для «крадіжки» руської спадщини."},{"question":"Давньоруська мова найближча до:","options":["сучасної української","сучасної російської","сучасної білоруської"],"correctIndex":0,"explanation":"Лінгвістичні дослідження підтверджують це."},{"question":"Княгиня Ольга відома тим, що:","options":["заснувала Київ","перша з правителів Русі прийняла християнство","написала «Повість минулих літ»"],"correctIndex":1,"explanation":"Вона хрестилася в Константинополі."},{"question":"**[Інтеграція: пасив]** Офіційний документ: «Договір із Візантією ___ у 907 році.»","options":["підписано","підписували","підписується"],"correctIndex":0,"explanation":"Офіційний історичний текст → -но/-то."},{"question":"**[Інтеграція: регістр]** Науковий текст: «Походження назви «Русь» ___ багатьма дослідниками.»","options":["досліджено","досліджується","досліджували"],"correctIndex":1,"explanation":"Науковий стиль, тривалий процес → -ся."},{"question":"Який аргумент НЕ підтверджує, що Русь — українська?","options":["Київ — столиця Русі — в Україні","Давньоруська мова найближча до української","Москва називала себе «Руссю» з IX століття"],"correctIndex":2,"explanation":"Москва почала називатися «Росією» лише з 1721 року."}],"shuffleQuestions":true,"shuffleOptions":true,"showCorrectAnswers":true}}];
    const vocabData = [{"uk":"Русь","translit":"","en":"Rus","note":"Київська Русь — українська держава."},{"uk":"русини","translit":"","en":"Ruthenians","note":"Русини — мешканці Русі."},{"uk":"варяги","translit":"","en":"Varangians","note":"Варяги торгували по річках."},{"uk":"племена","translit":"","en":"tribes","note":"Слов'янські племена об'єдналися."},{"uk":"заснувати","translit":"","en":"to found (pf)","note":"Олег заснував державу зі столицею в Києві."},{"uk":"об'єднати","translit":"","en":"to unite (pf)","note":"Він об'єднав різні племена."},{"uk":"захопити","translit":"","en":"to capture (pf)","note":"Олег захопив Київ у 882 році."},{"uk":"правити","translit":"","en":"to rule (impf)","note":"Ольга правила як регентша."},{"uk":"спадщина","translit":"","en":"heritage, legacy","note":"Русь — українська спадщина."},{"uk":"спадкоємність","translit":"","en":"succession","note":"Московські претензії на спадкоємність — хибні."},{"uk":"імперія","translit":"","en":"empire","note":"Російська імперія виникла в 1721 році."},{"uk":"розвінчати","translit":"","en":"to debunk (pf)","note":"Розвінчати імперські міфи."},{"uk":"привласнити","translit":"","en":"to appropriate (pf)","note":"Росія намагається привласнити Русь."},{"uk":"перейменувати","translit":"","en":"to rename (pf)","note":"Петро I перейменував Московію."},{"uk":"фальсифікація","translit":"","en":"falsification","note":"Історична фальсифікація — злочин."}];
  
// Answer callout toggle (for new > [!answer] syntax)
function toggleAnswer(id, btn) {
  const el = document.getElementById(id);
  if (!el) return;
  const isUkrainian = document.querySelector('.level-badge')?.textContent.match(/B[12]|C[12]/);
  const showText = isUkrainian ? 'Показати відповідь' : 'Show Answer';
  const hideText = isUkrainian ? 'Сховати відповідь' : 'Hide Answer';
  const show = !el.classList.contains('show');
  if (show) {
    el.classList.add('show');
    btn.textContent = hideText;
    btn.classList.add('revealed');
  } else {
    el.classList.remove('show');
    btn.textContent = showText;
    btn.classList.remove('revealed');
  }
}

// Section navigation
function showSection(id) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
  document.getElementById(id)?.classList.add('active');
  document.querySelector('[data-section="' + id + '"]')?.classList.add('active');
}
document.querySelectorAll('.nav-tab').forEach(t => t.addEventListener('click', () => showSection(t.dataset.section)));

// Activity reset dispatcher
function resetActivity(sectionId) {
  const activity = activitiesData.find(a => a.id === sectionId);
  if (!activity) return;

  switch (activity.type) {
    case 'match-up':
      resetMatch(sectionId);
      break;
    case 'quiz':
      resetQuiz(sectionId);
      break;
    case 'true-false':
      resetTf(sectionId);
      break;
    case 'group-sort':
      resetSort(sectionId);
      break;
    case 'fill-blank':
    case 'gap-fill':
      resetFill(sectionId);
      break;
    case 'order':
    case 'unjumble':
      resetOrder(sectionId);
      break;
    case 'select':
      resetSelect(sectionId);
      break;
  }
}

// Initialize all activities from activitiesData array
document.addEventListener('DOMContentLoaded', () => {
  if (typeof activitiesData === 'undefined') return;

  activitiesData.forEach(activity => {
    switch (activity.type) {
      case 'match-up':
        initMatch(activity.id, activity.data);
        break;
      case 'quiz':
        initQuiz(activity.id, activity.data);
        break;
      case 'true-false':
        initTf(activity.id, activity.data);
        break;
      case 'group-sort':
        initSort(activity.id, activity.data);
        break;
      case 'fill-blank':
      case 'gap-fill':
        initFill(activity.id, activity.data);
        break;
      case 'order':
      case 'unjumble':
        initOrder(activity.id, activity.data);
        break;
      case 'select':
        initSelect(activity.id, activity.data);
        break;
    }
  });

  // Initialize vocabulary
  if (typeof initVocab === 'function') initVocab();
});


// Quiz Activity - supports multiple instances
const quizState = {};

function initQuiz(sectionId, data) {
  const c = document.getElementById(sectionId + '-container');
  if (!c || !data.questions || !data.questions.length) return;

  quizState[sectionId] = { score: 0, answered: 0, total: data.questions.length, data: data };

  c.innerHTML = '';
  data.questions.forEach((q, i) => {
    const sh = [...q.options].sort(() => Math.random() - 0.5);
    const cor = sh.indexOf(q.options[q.correctIndex]);
    const div = document.createElement('div');
    div.className = 'quiz-question';
    div.dataset.section = sectionId;
    div.innerHTML = '<h4>Q' + (i + 1) + ': ' + q.question + '</h4><div class="quiz-options">' + sh.map((o, j) => '<div class="quiz-option" data-c="' + (j === cor) + '" data-q="' + i + '" data-section="' + sectionId + '">' + o + '</div>').join('') + '</div><div class="quiz-explanation" id="' + sectionId + '-exp-' + i + '">' + (q.explanation || '') + '</div>';
    c.appendChild(div);
  });
  c.querySelectorAll('.quiz-option').forEach(o => o.addEventListener('click', handleQuiz));
}

function handleQuiz(e) {
  const opt = e.target, q = opt.closest('.quiz-question');
  const sectionId = opt.dataset.section;
  if (q.classList.contains('answered')) return;
  q.classList.add('answered');

  const state = quizState[sectionId];
  if (opt.dataset.c === 'true') {
    opt.classList.add('correct');
    state.score++;
  } else {
    opt.classList.add('wrong');
    q.querySelector('[data-c="true"]').classList.add('correct');
  }
  document.getElementById(sectionId + '-exp-' + opt.dataset.q)?.classList.add('show');
  document.getElementById(sectionId + '-score').textContent = state.score;
  state.answered++;
  if (state.answered === state.total) document.getElementById(sectionId + '-complete').classList.add('show');
}

function resetQuiz(sectionId) {
  const state = quizState[sectionId];
  if (!state) return;
  document.getElementById(sectionId + '-score').textContent = '0';
  document.getElementById(sectionId + '-complete')?.classList.remove('show');
  initQuiz(sectionId, state.data);
}


// True/False Activity - supports multiple instances
const tfState = {};

function initTf(sectionId, data) {
  const c = document.getElementById(sectionId + '-container');
  if (!c || !data.statements || !data.statements.length) return;

  tfState[sectionId] = { score: 0, answered: 0, total: data.statements.length, data: data };

  c.innerHTML = '';
  data.statements.forEach((s, i) => {
    const div = document.createElement('div');
    div.className = 'tf-statement';
    div.dataset.section = sectionId;
    div.innerHTML = '<p class="tf-text">' + s.statement + '</p>' +
      '<div class="tf-buttons">' +
      '<button class="tf-btn" data-value="true" data-idx="' + i + '" data-section="' + sectionId + '">True</button>' +
      '<button class="tf-btn" data-value="false" data-idx="' + i + '" data-section="' + sectionId + '">False</button>' +
      '</div>' +
      '<div class="tf-explanation" id="' + sectionId + '-exp-' + i + '">' + (s.explanation || '') + '</div>';
    div.dataset.correct = s.isTrue;
    c.appendChild(div);
  });
  c.querySelectorAll('.tf-btn').forEach(b => b.addEventListener('click', handleTf));
}

function handleTf(e) {
  const btn = e.target;
  const sectionId = btn.dataset.section;
  const idx = parseInt(btn.dataset.idx);
  const statement = btn.closest('.tf-statement');
  const state = tfState[sectionId];
  if (statement.classList.contains('answered')) return;

  statement.classList.add('answered');
  const correct = state.data.statements[idx].isTrue;
  const clicked = btn.dataset.value === 'true';

  if (clicked === correct) {
    btn.classList.add('correct');
    state.score++;
  } else {
    btn.classList.add('wrong');
    // Highlight the correct answer
    statement.querySelector('[data-value="' + correct + '"]').classList.add('correct');
  }

  const exp = document.getElementById(sectionId + '-exp-' + idx);
  if (exp && exp.textContent) exp.classList.add('show');

  document.getElementById(sectionId + '-score').textContent = state.score;
  state.answered++;
  if (state.answered === state.total) document.getElementById(sectionId + '-complete').classList.add('show');
}

function resetTf(sectionId) {
  const state = tfState[sectionId];
  if (!state) return;
  document.getElementById(sectionId + '-score').textContent = '0';
  document.getElementById(sectionId + '-complete')?.classList.remove('show');
  initTf(sectionId, state.data);
}


// Match Activity - supports multiple instances
const matchState = {};

function initMatch(sectionId, data) {
  const container = document.getElementById(sectionId + '-container');
  const leftCol = document.getElementById(sectionId + '-left');
  const rightCol = document.getElementById(sectionId + '-right');
  if (!container || !leftCol || !rightCol || !data.pairs || !data.pairs.length) return;

  const pairs = data.pairs;
  matchState[sectionId] = { selected: null, score: 0, matched: [], total: pairs.length, data: data };

  // Create left column items
  const shuffledLeft = pairs.map((p, i) => ({ text: p.left, idx: i })).sort(() => Math.random() - 0.5);
  leftCol.innerHTML = shuffledLeft.map(p => '<div class="match-item" data-pair="' + p.idx + '" data-section="' + sectionId + '" data-side="left">' + p.text + '</div>').join('');

  // Create right column items
  const shuffledRight = pairs.map((p, i) => ({ text: p.right, idx: i })).sort(() => Math.random() - 0.5);
  rightCol.innerHTML = shuffledRight.map(p => '<div class="match-item" data-pair="' + p.idx + '" data-section="' + sectionId + '" data-side="right">' + p.text + '</div>').join('');

  // Attach click handlers
  leftCol.querySelectorAll('.match-item').forEach(item => {
    item.addEventListener('click', () => handleMatchLeft(item));
  });
  rightCol.querySelectorAll('.match-item').forEach(item => {
    item.addEventListener('click', () => handleMatchRight(item));
  });
}

function handleMatchLeft(item) {
  const sectionId = item.dataset.section;
  const state = matchState[sectionId];
  if (item.classList.contains('matched')) return;

  const leftCol = document.getElementById(sectionId + '-left');
  leftCol.querySelectorAll('.match-item').forEach(i => i.classList.remove('selected'));
  item.classList.add('selected');
  state.selected = { el: item, pair: item.dataset.pair };
}

function handleMatchRight(item) {
  const sectionId = item.dataset.section;
  const state = matchState[sectionId];
  if (item.classList.contains('matched') || !state.selected) return;

  if (state.selected.pair === item.dataset.pair) {
    state.selected.el.classList.remove('selected');
    state.selected.el.classList.add('matched');
    item.classList.add('matched');
    state.matched.push({ left: state.selected.el, right: item });
    state.score++;
    document.getElementById(sectionId + '-score').textContent = state.score;
    drawMatchLines(sectionId);
    if (state.score === state.total) document.getElementById(sectionId + '-complete').classList.add('show');
  } else {
    item.classList.add('wrong');
    setTimeout(() => item.classList.remove('wrong'), 300);
  }
  state.selected = null;
}

function drawMatchLines(sectionId) {
  const svg = document.getElementById(sectionId + '-lines');
  const container = document.getElementById(sectionId + '-container');
  const state = matchState[sectionId];
  if (!svg || !container || !state) return;

  const r = container.getBoundingClientRect();
  svg.innerHTML = '';
  svg.setAttribute('viewBox', '0 0 ' + r.width + ' ' + r.height);
  state.matched.forEach(p => {
    const lr = p.left.getBoundingClientRect(), rr = p.right.getBoundingClientRect();
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', lr.right - r.left);
    line.setAttribute('y1', lr.top + lr.height / 2 - r.top);
    line.setAttribute('x2', rr.left - r.left);
    line.setAttribute('y2', rr.top + rr.height / 2 - r.top);
    line.setAttribute('stroke', '#26a269');
    line.setAttribute('stroke-width', '2');
    svg.appendChild(line);
  });
}

function resetMatch(sectionId) {
  const state = matchState[sectionId];
  if (!state) return;
  document.getElementById(sectionId + '-score').textContent = '0';
  document.getElementById(sectionId + '-complete')?.classList.remove('show');
  document.getElementById(sectionId + '-lines').innerHTML = '';
  initMatch(sectionId, state.data);
}

// Redraw lines on resize for all match activities
window.addEventListener('resize', () => {
  Object.keys(matchState).forEach(sectionId => drawMatchLines(sectionId));
});


// Sort Activity - supports multiple instances
const sortState = {};

function initSort(sectionId, data) {
  const pool = document.getElementById(sectionId + '-items');
  const groupsContainer = document.getElementById(sectionId + '-groups');
  if (!pool || !groupsContainer || !data.groups || !data.groups.length) return;

  const groups = data.groups;
  const totalItems = groups.reduce((sum, g) => sum + g.items.length, 0);
  sortState[sectionId] = { score: 0, total: totalItems, dragItem: null, data: data };

  // Create group containers
  groupsContainer.innerHTML = groups.map((g, i) =>
    '<div class="sort-group" data-group="' + i + '" data-section="' + sectionId + '"><h4>' + g.name + '</h4><div class="sort-items"></div></div>'
  ).join('');

  // Flatten and shuffle all items
  const allItems = groups.flatMap((g, gi) => g.items.map(item => ({ text: item, group: gi })));
  allItems.sort(() => Math.random() - 0.5);

  // Create draggable items
  pool.innerHTML = '';
  allItems.forEach(item => {
    const el = document.createElement('div');
    el.className = 'sort-item';
    el.textContent = item.text;
    el.draggable = true;
    el.dataset.group = item.group;
    el.dataset.section = sectionId;
    el.addEventListener('dragstart', () => {
      sortState[sectionId].dragItem = el;
      el.classList.add('dragging');
    });
    el.addEventListener('dragend', () => {
      el.classList.remove('dragging');
      sortState[sectionId].dragItem = null;
    });
    pool.appendChild(el);
  });

  // Setup drop zones
  groupsContainer.querySelectorAll('.sort-group').forEach(g => {
    g.addEventListener('dragover', e => {
      e.preventDefault();
      g.classList.add('drag-over');
    });
    g.addEventListener('dragleave', () => g.classList.remove('drag-over'));
    g.addEventListener('drop', e => handleSortDrop(e, g));
  });
}

function handleSortDrop(e, groupEl) {
  e.preventDefault();
  groupEl.classList.remove('drag-over');
  const sectionId = groupEl.dataset.section;
  const state = sortState[sectionId];
  const dragItem = state.dragItem;
  if (!dragItem) return;

  if (groupEl.dataset.group === dragItem.dataset.group) {
    dragItem.classList.add('correct');
    groupEl.querySelector('.sort-items').appendChild(dragItem);
    dragItem.draggable = false;
    state.score++;
    document.getElementById(sectionId + '-score').textContent = state.score;
    if (state.score === state.total) document.getElementById(sectionId + '-complete').classList.add('show');
  } else {
    dragItem.classList.add('wrong');
    setTimeout(() => dragItem.classList.remove('wrong'), 300);
  }
}

function resetSort(sectionId) {
  const state = sortState[sectionId];
  if (!state) return;
  document.getElementById(sectionId + '-score').textContent = '0';
  document.getElementById(sectionId + '-complete')?.classList.remove('show');
  initSort(sectionId, state.data);
}


// Fill-in Activity - supports multiple instances
const fillState = {};

function initFill(sectionId, data) {
  const c = document.getElementById(sectionId + '-container');
  if (!c || !data.items || !data.items.length) return;

  fillState[sectionId] = { score: 0, answered: 0, total: data.items.length, data: data };
  c.innerHTML = '';

  data.items.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'fill-question';
    div.dataset.section = sectionId;

    // Generate options: correct answer + 3 distractors
    let options = [];
    if (item.options && item.options.length >= 4) {
      options = item.options;
    } else {
      // Fallback: generate distractors from other items' answers
      options = [item.answer];
      const otherAnswers = data.items
        .filter((_, idx) => idx !== i)
        .map(it => it.answer)
        .filter(a => a && a !== item.answer);

      const shuffled = otherAnswers.sort(() => Math.random() - 0.5);
      options.push(...shuffled.slice(0, 3));

      while (options.length < 4) {
        options.push('—');
      }
    }

    // Shuffle options
    const shuffledOptions = [...options].sort(() => Math.random() - 0.5);

    // Replace ___ in the sentence with a dropdown
    const sentence = (item.prompt || item.sentence || '').replace(/___/g,
      `<select class="fill-dropdown" data-idx="${i}" data-answer="${item.answer}" data-section="${sectionId}">
        <option value="" disabled selected>—</option>
        ${shuffledOptions.map(opt => `<option value="${opt}">${opt}</option>`).join('')}
      </select>`
    );

    div.innerHTML = `
      <div class="fill-sentence">
        <span class="fill-number">${i + 1}.</span>
        ${sentence}
      </div>
      <div class="fill-feedback" id="${sectionId}-fb-${i}"></div>
    `;
    c.appendChild(div);
  });

  // Event delegation for dropdown changes
  c.addEventListener('change', (e) => {
    if (e.target.classList.contains('fill-dropdown')) {
      handleFillChoice(e.target);
    }
  });
}

function handleFillChoice(dropdown) {
  const q = dropdown.closest('.fill-question');
  const sectionId = dropdown.dataset.section;
  const state = fillState[sectionId];
  if (q.classList.contains('answered')) return;

  const idx = dropdown.dataset.idx;
  const userAnswer = dropdown.value;
  const correctAnswer = dropdown.dataset.answer;
  const fb = document.getElementById(sectionId + '-fb-' + idx);

  q.classList.add('answered');
  dropdown.disabled = true;

  if (userAnswer === correctAnswer) {
    dropdown.classList.add('correct');
    fb.innerHTML = '<span class="correct-text">✓ Correct!</span>';
    state.score++;
  } else {
    dropdown.classList.add('wrong');
    fb.innerHTML = `<span class="wrong-text">✗ Answer: ${correctAnswer}</span>`;
  }

  document.getElementById(sectionId + '-score').textContent = state.score;
  state.answered++;
  if (state.answered === state.total) {
    document.getElementById(sectionId + '-complete').classList.add('show');
  }
}

function resetFill(sectionId) {
  const state = fillState[sectionId];
  if (!state) return;
  document.getElementById(sectionId + '-score').textContent = '0';
  document.getElementById(sectionId + '-complete')?.classList.remove('show');
  initFill(sectionId, state.data);
}


// Order/Unjumble Activity - supports multiple instances
const orderState = {};

function initOrder(sectionId, data) {
  const c = document.getElementById(sectionId + '-container');
  if (!c || !data.items || !data.items.length) return;

  orderState[sectionId] = { score: 0, total: data.items.length, data: data };
  c.innerHTML = '';

  if (data.isUnjumble) {
    initUnjumble(sectionId, c, data);
  } else {
    initClassicOrder(sectionId, c, data);
  }
}

// UNJUMBLE: Drag-and-drop words to form sentences
function initUnjumble(sectionId, container, data) {
  data.items.forEach((item, idx) => {
    const question = document.createElement('div');
    question.className = 'unjumble-question';
    question.dataset.idx = idx;
    question.dataset.section = sectionId;

    // Shuffle words
    const shuffledWords = [...item.words].sort(() => Math.random() - 0.5);

    question.innerHTML = `
      <div class="unjumble-number">${idx + 1}.</div>
      <div class="unjumble-word-row" data-idx="${idx}" data-section="${sectionId}">
        ${shuffledWords.map((word, i) => `
          <span class="unjumble-word" draggable="true" data-word="${word}">${word}</span>
        `).join('')}
      </div>
      <div class="unjumble-actions">
        <button class="btn btn-sm btn-outline unjumble-check" data-idx="${idx}" data-section="${sectionId}">Check</button>
        <button class="btn btn-sm btn-outline unjumble-reset" data-idx="${idx}" data-section="${sectionId}">Reset</button>
      </div>
      <div class="unjumble-feedback" data-idx="${idx}" data-section="${sectionId}"></div>
    `;

    container.appendChild(question);

    // Initialize drag-and-drop for this row
    initUnjumbleDragDrop(question.querySelector('.unjumble-word-row'));
  });

  // Event delegation for buttons
  container.addEventListener('click', handleUnjumbleClick);
}

function initUnjumbleDragDrop(row) {
  let dragItem = null;

  row.querySelectorAll('.unjumble-word').forEach(word => {
    word.addEventListener('dragstart', (e) => {
      dragItem = word;
      word.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });

    word.addEventListener('dragend', () => {
      word.classList.remove('dragging');
      dragItem = null;
    });

    word.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (!dragItem || dragItem === word) return;

      const rect = word.getBoundingClientRect();
      const midX = rect.left + rect.width / 2;

      if (e.clientX < midX) {
        row.insertBefore(dragItem, word);
      } else {
        row.insertBefore(dragItem, word.nextSibling);
      }
    });
  });

  // Touch support for mobile
  let touchItem = null;
  let touchClone = null;

  row.querySelectorAll('.unjumble-word').forEach(word => {
    word.addEventListener('touchstart', (e) => {
      touchItem = word;
      word.classList.add('dragging');

      // Create a clone for visual feedback
      touchClone = word.cloneNode(true);
      touchClone.classList.add('touch-clone');
      document.body.appendChild(touchClone);
      updateTouchClone(e.touches[0]);
    });

    word.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!touchItem) return;
      updateTouchClone(e.touches[0]);

      // Find which word we're over
      const touch = e.touches[0];
      const elements = document.elementsFromPoint(touch.clientX, touch.clientY);
      const targetWord = elements.find(el => el.classList.contains('unjumble-word') && el !== touchItem);

      if (targetWord && targetWord.parentNode === row) {
        const rect = targetWord.getBoundingClientRect();
        const midX = rect.left + rect.width / 2;
        if (touch.clientX < midX) {
          row.insertBefore(touchItem, targetWord);
        } else {
          row.insertBefore(touchItem, targetWord.nextSibling);
        }
      }
    });

    word.addEventListener('touchend', () => {
      if (touchItem) touchItem.classList.remove('dragging');
      if (touchClone) touchClone.remove();
      touchItem = null;
      touchClone = null;
    });
  });

  function updateTouchClone(touch) {
    if (touchClone) {
      touchClone.style.left = (touch.clientX - 40) + 'px';
      touchClone.style.top = (touch.clientY - 20) + 'px';
    }
  }
}

function handleUnjumbleClick(e) {
  const target = e.target;

  if (target.classList.contains('unjumble-check')) {
    checkUnjumbleAnswer(target.dataset.section, parseInt(target.dataset.idx));
  }

  if (target.classList.contains('unjumble-reset')) {
    resetUnjumbleQuestion(target.dataset.section, parseInt(target.dataset.idx));
  }
}

function checkUnjumbleAnswer(sectionId, idx) {
  const state = orderState[sectionId];
  const item = state.data.items[idx];
  const row = document.querySelector(`.unjumble-word-row[data-section="${sectionId}"][data-idx="${idx}"]`);
  const feedback = document.querySelector(`.unjumble-feedback[data-section="${sectionId}"][data-idx="${idx}"]`);
  const question = document.querySelector(`.unjumble-question[data-section="${sectionId}"][data-idx="${idx}"]`);

  // Build user's answer from current word order
  const words = row.querySelectorAll('.unjumble-word');
  const userAnswer = Array.from(words).map(w => w.dataset.word).join(' ');

  // Normalize for comparison (handle punctuation)
  const normalize = (s) => s.replace(/[?!.,]/g, '').toLowerCase().trim();
  const isCorrect = normalize(userAnswer) === normalize(item.answer);

  if (isCorrect) {
    question.classList.add('answered', 'correct');
    row.classList.add('correct');
    words.forEach(w => w.setAttribute('draggable', 'false'));
    state.score++;
    document.getElementById(sectionId + '-score').textContent = state.score;

    feedback.innerHTML = `
      <span class="correct-text">✓ Correct!</span>
      <span class="translation">${item.translation || ''}</span>
    `;
    feedback.classList.add('show');

    if (state.score === state.total) {
      document.getElementById(sectionId + '-complete').classList.add('show');
    }
  } else {
    question.classList.add('wrong');
    row.classList.add('wrong');

    feedback.innerHTML = `
      <span class="wrong-text">✗ Try again. Hint: ${item.answer}</span>
    `;
    feedback.classList.add('show');

    setTimeout(() => {
      question.classList.remove('wrong');
      row.classList.remove('wrong');
      feedback.classList.remove('show');
    }, 2000);
  }
}

function resetUnjumbleQuestion(sectionId, idx) {
  const state = orderState[sectionId];
  const item = state.data.items[idx];
  const row = document.querySelector(`.unjumble-word-row[data-section="${sectionId}"][data-idx="${idx}"]`);
  const question = document.querySelector(`.unjumble-question[data-section="${sectionId}"][data-idx="${idx}"]`);
  const feedback = document.querySelector(`.unjumble-feedback[data-section="${sectionId}"][data-idx="${idx}"]`);

  if (question.classList.contains('correct')) return;

  // Re-shuffle and rebuild
  const shuffledWords = [...item.words].sort(() => Math.random() - 0.5);
  row.innerHTML = shuffledWords.map(word => `
    <span class="unjumble-word" draggable="true" data-word="${word}">${word}</span>
  `).join('');

  initUnjumbleDragDrop(row);

  question.classList.remove('wrong');
  row.classList.remove('wrong');
  feedback.innerHTML = '';
  feedback.classList.remove('show');
}

// CLASSIC ORDER: Drag items into correct sequence
function initClassicOrder(sectionId, container, data) {
  const state = orderState[sectionId];

  // Create array with original indices, then shuffle
  const items = [...data.items].map((item, idx) => ({ text: item, origIdx: idx }));
  // Fisher-Yates shuffle
  for (let i = items.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [items[i], items[j]] = [items[j], items[i]];
  }

  // Create container div for all items
  const wrapper = document.createElement('div');
  wrapper.className = 'order-items-wrapper';
  wrapper.dataset.section = sectionId;

  // Create each sentence as a draggable item
  items.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'order-sentence-card';
    div.draggable = true;
    div.dataset.orig = item.origIdx;
    div.dataset.section = sectionId;
    div.innerHTML = '<span class="order-card-num">' + (i + 1) + '</span><span class="order-card-text">' + item.text + '</span>';
    wrapper.appendChild(div);
  });

  container.appendChild(wrapper);

  // Add buttons
  const btnDiv = document.createElement('div');
  btnDiv.className = 'order-buttons';
  btnDiv.innerHTML = '<button class="btn btn-outline order-check-btn" data-section="' + sectionId + '">Check Order</button>';
  container.appendChild(btnDiv);

  // Add feedback area
  const feedback = document.createElement('div');
  feedback.className = 'order-feedback';
  feedback.dataset.section = sectionId;
  container.appendChild(feedback);

  // Initialize drag-and-drop
  initOrderCardDragDrop(wrapper);

  // Button click handler
  btnDiv.querySelector('.order-check-btn').onclick = function() { checkOrder(sectionId); };
}

function initOrderCardDragDrop(wrapper) {
  let dragItem = null;

  wrapper.querySelectorAll('.order-sentence-card').forEach(function(card) {
    card.addEventListener('dragstart', function(e) {
      dragItem = card;
      card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });

    card.addEventListener('dragend', function() {
      card.classList.remove('dragging');
      dragItem = null;
      updateCardNumbers(wrapper);
    });

    card.addEventListener('dragover', function(e) {
      e.preventDefault();
      if (!dragItem || dragItem === card) return;
      const rect = card.getBoundingClientRect();
      const midY = rect.top + rect.height / 2;
      if (e.clientY < midY) {
        wrapper.insertBefore(dragItem, card);
      } else {
        wrapper.insertBefore(dragItem, card.nextSibling);
      }
    });
  });

  // Touch support
  let touchItem = null;
  let touchClone = null;

  wrapper.querySelectorAll('.order-sentence-card').forEach(function(card) {
    card.addEventListener('touchstart', function(e) {
      touchItem = card;
      card.classList.add('dragging');
      touchClone = card.cloneNode(true);
      touchClone.style.position = 'fixed';
      touchClone.style.zIndex = '1000';
      touchClone.style.pointerEvents = 'none';
      touchClone.style.opacity = '0.8';
      touchClone.style.maxWidth = '90vw';
      document.body.appendChild(touchClone);
      moveTouchClone(e.touches[0]);
    });

    card.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (!touchItem) return;
      moveTouchClone(e.touches[0]);
      const touch = e.touches[0];
      const els = document.elementsFromPoint(touch.clientX, touch.clientY);
      const target = els.find(function(el) { return el.classList.contains('order-sentence-card') && el !== touchItem; });
      if (target && target.parentNode === wrapper) {
        const rect = target.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        if (touch.clientY < midY) {
          wrapper.insertBefore(touchItem, target);
        } else {
          wrapper.insertBefore(touchItem, target.nextSibling);
        }
      }
    });

    card.addEventListener('touchend', function() {
      if (touchItem) touchItem.classList.remove('dragging');
      if (touchClone) touchClone.remove();
      touchItem = null;
      touchClone = null;
      updateCardNumbers(wrapper);
    });
  });

  function moveTouchClone(touch) {
    if (touchClone) {
      touchClone.style.left = (touch.clientX - 100) + 'px';
      touchClone.style.top = (touch.clientY - 25) + 'px';
    }
  }
}

function updateCardNumbers(wrapper) {
  wrapper.querySelectorAll('.order-sentence-card').forEach(function(card, i) {
    card.querySelector('.order-card-num').textContent = i + 1;
  });
}

function initOrderSentenceDragDrop(row) {
  let dragItem = null;

  row.querySelectorAll('.order-sentence-item').forEach(item => {
    item.addEventListener('dragstart', (e) => {
      dragItem = item;
      item.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });

    item.addEventListener('dragend', () => {
      item.classList.remove('dragging');
      dragItem = null;
      // Update numbers after drag
      updateOrderNumbers(row);
    });

    item.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (!dragItem || dragItem === item) return;

      const rect = item.getBoundingClientRect();
      const midY = rect.top + rect.height / 2;

      if (e.clientY < midY) {
        row.insertBefore(dragItem, item);
      } else {
        row.insertBefore(dragItem, item.nextSibling);
      }
    });
  });

  // Touch support
  let touchItem = null;
  let touchClone = null;

  row.querySelectorAll('.order-sentence-item').forEach(item => {
    item.addEventListener('touchstart', (e) => {
      touchItem = item;
      item.classList.add('dragging');
      touchClone = item.cloneNode(true);
      touchClone.classList.add('touch-clone');
      document.body.appendChild(touchClone);
      updateTouchClonePos(e.touches[0], touchClone);
    });

    item.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!touchItem) return;
      updateTouchClonePos(e.touches[0], touchClone);

      const touch = e.touches[0];
      const elements = document.elementsFromPoint(touch.clientX, touch.clientY);
      const target = elements.find(el => el.classList.contains('order-sentence-item') && el !== touchItem);

      if (target && target.parentNode === row) {
        const rect = target.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        if (touch.clientY < midY) {
          row.insertBefore(touchItem, target);
        } else {
          row.insertBefore(touchItem, target.nextSibling);
        }
      }
    });

    item.addEventListener('touchend', () => {
      if (touchItem) touchItem.classList.remove('dragging');
      if (touchClone) touchClone.remove();
      touchItem = null;
      touchClone = null;
      updateOrderNumbers(row);
    });
  });

  function updateTouchClonePos(touch, clone) {
    if (clone) {
      clone.style.left = (touch.clientX - 100) + 'px';
      clone.style.top = (touch.clientY - 20) + 'px';
    }
  }
}

function updateOrderNumbers(row) {
  row.querySelectorAll('.order-sentence-item').forEach((item, i) => {
    item.querySelector('.order-num').textContent = i + 1;
  });
}

function initDragDrop(container) {
  const items = container.querySelectorAll('.order-item');
  let dragItem = null;

  items.forEach(item => {
    item.addEventListener('dragstart', (e) => {
      dragItem = item;
      item.classList.add('dragging');
    });

    item.addEventListener('dragend', () => {
      item.classList.remove('dragging');
      dragItem = null;
    });

    item.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (!dragItem || dragItem === item) return;
      const rect = item.getBoundingClientRect();
      const midY = rect.top + rect.height / 2;
      if (e.clientY < midY) {
        container.insertBefore(dragItem, item);
      } else {
        container.insertBefore(dragItem, item.nextSibling);
      }
    });
  });
}

function checkOrder(sectionId) {
  const state = orderState[sectionId];
  const data = state.data;
  // Support multiple class names for order items
  let items = document.querySelectorAll('.order-sentence-card[data-section="' + sectionId + '"]');
  if (!items.length) {
    items = document.querySelectorAll('.order-sentence-item[data-section="' + sectionId + '"]');
  }
  if (!items.length) {
    items = document.querySelectorAll('.order-item[data-section="' + sectionId + '"]');
  }
  const currentOrder = Array.from(items).map(function(item) { return parseInt(item.dataset.orig); });
  const feedback = document.querySelector('.order-feedback[data-section="' + sectionId + '"]');

  let correct = true;
  currentOrder.forEach((val, idx) => {
    const expectedIdx = data.correctOrder && data.correctOrder.length ? data.correctOrder[idx] : idx;
    if (val !== expectedIdx) correct = false;
  });

  items.forEach((item, idx) => {
    const expectedIdx = data.correctOrder && data.correctOrder.length ? data.correctOrder[idx] : idx;
    if (parseInt(item.dataset.orig) === expectedIdx) {
      item.classList.add('correct');
      item.classList.remove('wrong');
    } else {
      item.classList.add('wrong');
      item.classList.remove('correct');
    }
  });

  if (correct) {
    state.score = state.total;
    document.getElementById(sectionId + '-score').textContent = state.score;
    document.getElementById(sectionId + '-complete').classList.add('show');
    if (feedback) {
      feedback.innerHTML = '<span class="correct-text">✓ Perfect order!</span>';
      feedback.classList.add('show');
    }
  } else {
    if (feedback) {
      feedback.innerHTML = '<span class="wrong-text">✗ Not quite right. Try again!</span>';
      feedback.classList.add('show');
    }
    setTimeout(function() {
      items.forEach(function(item) { item.classList.remove('wrong'); });
      if (feedback) feedback.classList.remove('show');
    }, 2000);
  }
}

function resetOrder(sectionId) {
  const state = orderState[sectionId];
  if (!state) return;
  document.getElementById(sectionId + '-score').textContent = '0';
  document.getElementById(sectionId + '-complete')?.classList.remove('show');
  initOrder(sectionId, state.data);
}


// Select Activity - supports multiple instances
const selectState = {};

function initSelect(sectionId, data) {
  const c = document.getElementById(sectionId + '-container');
  if (!c || !data.items || !data.items.length) return;

  selectState[sectionId] = { score: 0, answered: 0, total: data.items.length, data: data };
  c.innerHTML = '';

  data.items.forEach((item, idx) => {
    const div = document.createElement('div');
    div.className = 'select-question';
    div.dataset.section = sectionId;
    div.dataset.idx = idx;

    const optionsHtml = item.options.map((opt, oi) =>
      `<label class="select-option" data-correct="${opt.correct}" data-section="${sectionId}" data-idx="${idx}">
        <input type="checkbox" class="select-checkbox" data-oi="${oi}">
        <span class="select-text">${opt.text}</span>
      </label>`
    ).join('');

    div.innerHTML = `
      <div class="select-number">${idx + 1}.</div>
      <div class="select-content">
        <p class="select-prompt">${item.question}</p>
        <div class="select-options">${optionsHtml}</div>
        <button class="btn btn-sm btn-outline select-check" data-section="${sectionId}" data-idx="${idx}">Check</button>
        <div class="select-feedback" id="${sectionId}-fb-${idx}"></div>
      </div>
    `;
    c.appendChild(div);
  });

  // Event delegation for check buttons
  c.addEventListener('click', (e) => {
    if (e.target.classList.contains('select-check')) {
      checkSelectAnswer(e.target.dataset.section, parseInt(e.target.dataset.idx));
    }
  });
}

function checkSelectAnswer(sectionId, idx) {
  const state = selectState[sectionId];
  const item = state.data.items[idx];
  const question = document.querySelector(`.select-question[data-section="${sectionId}"][data-idx="${idx}"]`);
  const fb = document.getElementById(sectionId + '-fb-' + idx);

  if (question.classList.contains('answered')) return;

  const options = question.querySelectorAll('.select-option');
  let allCorrect = true;

  options.forEach(opt => {
    const checkbox = opt.querySelector('.select-checkbox');
    const isChecked = checkbox.checked;
    const shouldBeChecked = opt.dataset.correct === 'true';

    if (isChecked === shouldBeChecked) {
      opt.classList.add(shouldBeChecked ? 'correct' : 'correct-unchecked');
    } else {
      opt.classList.add(shouldBeChecked ? 'missed' : 'wrong');
      allCorrect = false;
    }
    checkbox.disabled = true;
  });

  question.classList.add('answered');

  if (allCorrect) {
    fb.innerHTML = '<span class="correct-text">✓ Perfect!</span>';
    state.score++;
  } else {
    fb.innerHTML = '<span class="wrong-text">✗ Some answers were incorrect.</span>';
  }
  fb.classList.add('show');

  document.getElementById(sectionId + '-score').textContent = state.score;
  state.answered++;

  if (state.answered === state.total) {
    document.getElementById(sectionId + '-complete').classList.add('show');
  }
}

function resetSelect(sectionId) {
  const state = selectState[sectionId];
  if (!state) return;
  document.getElementById(sectionId + '-score').textContent = '0';
  document.getElementById(sectionId + '-complete')?.classList.remove('show');
  initSelect(sectionId, state.data);
}


// Vocabulary
function initVocab() {
  const grid = document.getElementById('vocab-grid');
  if (!grid) return;
  grid.innerHTML = '';
  vocabData.forEach(v => {
    const card = document.createElement('div');
    card.className = 'vocab-card';
    card.innerHTML = '<div class="uk">' + v.uk + '</div><div class="translit">' + v.translit + '</div><div class="en">' + v.en + '</div>' + (v.note ? '<div class="note">' + v.note + '</div>' : '');
    grid.appendChild(card);
  });
}

  </script>
</body>
</html>